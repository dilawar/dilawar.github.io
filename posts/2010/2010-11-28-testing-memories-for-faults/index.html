<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<title>Testing memories for faults | Dilawar's Blog</title>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=generator content="Hugo 0.89.2">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=keywords content="ghdl,memory-testing,pattern-sensitive-faults,stuck-at-faults,verification,vhdl">
<link rel=stylesheet type=text/css media=screen href=/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=/css/main.css>
<link rel=stylesheet type=text/css media=screen href=/css/all.css><link rel=stylesheet href=/css/katex.css crossorigin=anonymous>
<script defer src=/js/katex.js integrity=sha384-PFWG8XW41D5NzhNv5FegM1CUkw9nNLdWug8DuwnUoNEVop9n5frjcnbtsZtxTNjw crossorigin=anonymous></script>
<script defer src=/js/auto-render.js integrity=sha384-EN2q+JG5/3Z8gD7hT5WZqq+W+9wQR4P3IezfuZmGG5RkNXaaaks85seDJO7WkZlY crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script>
<meta property="og:title" content="Testing memories for faults">
<meta property="og:description" content="As the VLSI memories are shrinking in their size, the density of cells which holds data is increasing exponentially. If one is making a living out of manufacturing them then he must make sure product he is releasing in the market is fault free. So he must hire some trained person to test memories of how much they are faulty. I wish I could do that with my natural memory .">
<meta property="og:type" content="article">
<meta property="og:url" content="https://dilawar.github.io/posts/2010/2010-11-28-testing-memories-for-faults/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2010-11-28T00:00:00+00:00">
<meta property="article:modified_time" content="2010-11-28T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Testing memories for faults">
<meta name=twitter:description content="As the VLSI memories are shrinking in their size, the density of cells which holds data is increasing exponentially. If one is making a living out of manufacturing them then he must make sure product he is releasing in the market is fault free. So he must hire some trained person to test memories of how much they are faulty. I wish I could do that with my natural memory .">
<meta itemprop=name content="Testing memories for faults">
<meta itemprop=description content="As the VLSI memories are shrinking in their size, the density of cells which holds data is increasing exponentially. If one is making a living out of manufacturing them then he must make sure product he is releasing in the market is fault free. So he must hire some trained person to test memories of how much they are faulty. I wish I could do that with my natural memory ."><meta itemprop=datePublished content="2010-11-28T00:00:00+00:00">
<meta itemprop=dateModified content="2010-11-28T00:00:00+00:00">
<meta itemprop=wordCount content="3703">
<meta itemprop=keywords content="ghdl,memory-testing,pattern-sensitive-faults,stuck-at-faults,verification,vhdl,">
</head>
<body>
<header>
<div id=titletext>
<h2 id=title><a href=https://dilawar.github.io>Dilawar's Blog</a></h2>
</div>
<div id=title-description>
<p id=subtitle>watch -n 1 /dev/null</p>
<div id=social>
<nav><ul>
<li><a href=https://github.com/dilawar><i title=Github class="icons fab fa-github"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id=mainmenu>
<nav>
<ul>
<li><a href=/>Home</a></li>
<li><a href=/posts>All posts</a></li>
<li><a href=/about>About</a></li>
<li><a href=/tags>Tags</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class=post>
<article>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>28</span>
<span class=rest>Nov 2010</span>
</div>
</div>
<div class=matter>
<h1 class=title>Testing memories for faults</h1>
<p class=post-meta>
<span class=post-meta>
</span>
</p>
</div>
</div>
<div class=markdown>
<p>As the VLSI memories are shrinking in their size, the density of cells which holds data is increasing exponentially. If one is making a living out of manufacturing them then he must make sure product he is releasing in the market is fault free. So he must hire some trained person to test memories of how much they are faulty. <strong>I wish I could do that with my natural memory</strong> . So at least he can make an informed decision whether he should sell his faulty product. In memories many kind of faults can occur. Most prominent of those are <strong>stuck-at faults</strong> (when some bit is permanently stuck to 0 or 1 value); <strong>coupling faults</strong> (write in in one location of memory can change the values at some other location), and <strong>Pattern Sensitive Faults</strong> (a certain pattern in some locations of memory will not allow to write at some address.) Another kind of faults are <strong>Decoder faults</strong> in which decoder itself have some faults (thus more than one addresses are mapped onto one address and any write will write at multiple locations). Not all of these faults can be test by a single test. Testing for all the faults are time consuming because they are so many of them. However if certain combination of tests, will limited yet sufficient coverage, does not detect faults in memory then one can be pretty sure that this memory does not contain many faults which are undetected. <a href=http://digitalelectronics.blogspot.com/2009/01/memories-memory-faults-part-4.html target=_blank>See this</a> Here in this post, We give some primitive tests Â to detect these faults. Lets say following is my memory block. [sourcecode language=&ldquo;text&rdquo;] entity MemBlock is generic(has_decoder_fault, has_stuck_at_fault, has_psf, has_cf: boolean := false); port(addr, data_in: in bit_vector(7 downto 0); read_en, write_en: in bit; data_out: out bit_vector(7 downto 0)); end entity; architecture Behave of MemBlock is type MemArray is array (natural range &lt;>) of bit_vector(7 downto 0); &ndash; procedure that models the update of the memory array, &ndash; given an incoming word (data_in) and a row index (I) procedure Update_Mem(signal mem_array: inout MemArray;I: in integer; data_in: in bit_vector(7 downto 0)) is variable cword: bit_vector(7 downto 0); variable uI, dI: integer; variable aflag : boolean; &ndash; set true when write is over. begin aflag := false; &ndash; PSF if(I = 128 and has_psf) then uI := 129; dI := 127; cword := mem_array(I); for J in 7 downto 0 loop &ndash; here is the PSF if not ( mem_array(uI)(J) = &lsquo;1&rsquo; and mem_array(dI)(J) = &lsquo;1&rsquo;) then mem_array(I)(J) &lt;= data_in(J); end if; end loop; aflag := true; end if; if(I=127 and has_cf) then if(mem_array(127)(0) = &lsquo;0&rsquo; and data_in(0) = &lsquo;1&rsquo;) then mem_array(128)(0) &lt;= &lsquo;1&rsquo;; end if; mem_array(127) &lt;= data_in; aflag := true; end if; if(I=129 and has_cf) then if(mem_array(129)(0) = &lsquo;0&rsquo; and data_in(0) = &lsquo;1&rsquo;) then mem_array(128)(0) &lt;= &lsquo;0&rsquo;; end if; mem_array(129) &lt;= data_in; aflag := true; end if; if(not aflag) then mem_array(I) &lt;= data_in; end if; if(has_stuck_at_fault) then mem_array(129)(0) &lt;= &lsquo;1&rsquo;; mem_array(128)(0) &lt;= &lsquo;0&rsquo;; end if; end procedure; &ndash; converts bit vector to a natural number function To_Natural(x: bit_vector) return natural is variable ret_var : natural := 0; alias lx: bit_vector(x&rsquo;length downto 1) is x; begin for I in 1 to lx&rsquo;length loop if(lx(I) = &lsquo;1&rsquo;) then ret_var := ret_var + (2**(I-1)); end if; end loop; return(ret_var); end To_Natural; &ndash; output of the decoder signal decode_sig: bit_vector(255 downto 0); &ndash; memory array signal mem_array: MemArray(0 to 255); begin &ndash; decoder process process(addr) begin decode_sig &lt;= (others => &lsquo;0&rsquo;); for I in 0 to 255 loop if(I=To_Natural(addr)) then decode_sig(I) &lt;= &lsquo;1&rsquo;; if(I=128 and has_decoder_fault) then decode_sig(I+1) &lt;= &lsquo;1&rsquo;; end if; end if; end loop; end process; &ndash; memory array access process process(addr, data_in, read_en, write_en) variable data_out_var: bit_vector(7 downto 0); begin data_out_var := (others => &lsquo;0&rsquo;); for I in 0 to 255 loop if decode_sig(I) = &lsquo;1&rsquo; then if(read_en = &lsquo;1&rsquo;) then data_out_var := data_out_var or mem_array(I); &ndash; Wired OR elsif write_en = &lsquo;1&rsquo; then Update_Mem(mem_array,I,data_in); end if; end if; end loop; data_out &lt;= data_out_var; end process; end Behave; [/sourcecode] Now here is another file which instantiate these memory blocks with faults in it. [sourcecode language=&ldquo;text&rdquo;] entity MemTest is end entity MemTest; architecture Behave of MemTest is &ndash; utility function: to increment an address function Increment(x: bit_vector) return bit_vector is alias lx: bit_vector(1 to x&rsquo;length) is x; variable ret_var: bit_vector(1 to x&rsquo;length); variable carry: bit; begin carry := &lsquo;1&rsquo;; for I in x&rsquo;length downto 1 loop ret_var(I) := lx(I) xor carry; carry := carry and lx(I); end loop; return(ret_var); end Increment; signal addr, data_in, data_out_df, data_out_saf, data_out_psf,data_out_cf : bit_vector(7 downto 0); signal read_en, write_en: bit; &ndash; memory block &ndash; array of 8 bit words, with 8 bit address. &ndash; with the following behaviour. &ndash; &ndash; if read_en = &lsquo;1&rsquo; then &ndash; data_out = memory_contents(addr); &ndash; elsif write_en = &lsquo;1&rsquo; then &ndash; memory_contents(addr) = data_in; &ndash; component MemBlock generic(has_decoder_fault, has_stuck_at_fault, has_psf, has_cf: boolean := false); port(addr, data_in: in bit_vector(7 downto 0); read_en, write_en: in bit; data_out: out bit_vector(7 downto 0)); end component; constant zero8: bit_vector(7 downto 0) := (others => &lsquo;0&rsquo;); &ndash; utility procedures &ndash; Write addr/data pair into memory using write_en procedure Write(signal addr: out bit_vector(7 downto 0); signal data: out bit_vector(7 downto 0); signal write_en: out bit; addr_var: in bit_vector(7 downto 0); data_var: in bit_vector(7 downto 0)) is begin addr &lt;= addr_var; data &lt;= data_var; wait for 1 ns; write_en &lt;= &lsquo;1&rsquo;; wait for 1 ns; write_en &lt;= &lsquo;0&rsquo;; wait for 1 ns; end procedure; &ndash; Read data from memory using read_en, addr. &ndash; NOTE: data must be present on data_out signal on &ndash; completion of procedure. procedure Read(signal addr: out bit_vector(7 downto 0); signal read_en: out bit; addr_var: bit_vector(7 downto 0)) is begin addr &lt;= addr_var; wait for 1 ns; read_en &lt;= &lsquo;1&rsquo;; wait for 1 ns; read_en &lt;= &lsquo;0&rsquo;; end procedure; begin &ndash; four memory blocks, each of which has one type of fault in it. &ndash; this has a decoder-fault mb_df: MemBlock generic map(has_decoder_fault => true, has_stuck_at_fault => false, has_psf => false, has_cf => false) port map(addr => addr, data_in => data_in, data_out => data_out_df, read_en => read_en, write_en => write_en); &ndash; this has stuck-at-faults in the array mb_saf: MemBlock generic map(has_decoder_fault => false, has_stuck_at_fault => true, has_psf => false, has_cf => false) port map(addr => addr, data_in => data_in, data_out => data_out_saf, read_en => read_en, write_en => write_en); &ndash; this has a pattern-sensitive-fault in the array. The neighbourhood for the &ndash; fault is adjacent bits in the same column of the array. mb_psf: MemBlock generic map(has_decoder_fault => false, has_stuck_at_fault => false, has_psf => true, has_cf => false) port map(addr => addr, data_in => data_in, data_out => data_out_psf, read_en => read_en, write_en => write_en); &ndash; this has some coupling faults in the array mb_cf: MemBlock generic map(has_decoder_fault => false, has_stuck_at_fault => false, has_psf => false, has_cf => true) port map(addr => addr, data_in => data_in, data_out => data_out_cf, read_en => read_en, write_en => write_en); &mdash;&mdash;&mdash;&mdash;- test process &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; process variable curr_addr, next_addr: bit_vector(7 downto 0); variable err_flag : boolean := false; begin &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- &ndash; TEST SEQUENCE STARTS HERE &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- read_en &lt;= &lsquo;0&rsquo;; write_en &lt;= &lsquo;0&rsquo;; wait for 1 ns; curr_addr := (others => &lsquo;0&rsquo;); while true loop &ndash; write followed by read Write(addr,data_in,write_en,curr_addr,curr_addr); Read(addr,read_en,curr_addr); &ndash; check data_out assert (data_out_df = curr_addr) report &ldquo;Data mismatch in memory with decoder fault&rdquo; severity ERROR; assert (data_out_saf = curr_addr) report &ldquo;Data mismatch in memory with stuck-at-fault&rdquo; severity ERROR; assert (data_out_psf = curr_addr) report &ldquo;Data mismatch in memory with pattern-sensitive-fault&rdquo; severity ERROR; assert (data_out_cf = curr_addr) report &ldquo;Data mismatch in memory with coupling-fault&rdquo; severity ERROR; err_flag := err_flag or (data_out_df /= curr_addr) or (data_out_saf /= curr_addr) or (data_out_psf /= curr_addr) or (data_out_cf /= curr_addr); next_addr := Increment(addr); if(next_addr = zero8) then exit; end if; curr_addr := next_addr; end loop; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- &ndash; TEST SEQUENCE ENDS HERE &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- assert not err_flag report &ldquo;Test Failed&rdquo; severity ERROR; assert err_flag report &ldquo;Test Passed&rdquo; severity NOTE; wait; end process; end Behave; [/sourcecode] <strong>If you run the simulation using the algorithm in this existing test bench, the memory block seems to be functioning correctly. However, each of the memory blocks has faults present in it (as you can verify by examining the VHDL code). Why did the test fail to detect the errors? Now one needs to modify the test-bench to use a single test (sequence of reads and writes) that can detect any decoder/stuck-at/coupling/pattern-sensitive fault in MemBlock. Pattern-sensitive faults may be assumed to be for a neighbourhood which consists of adjacent bits in the same column of the 256x8 array. Conï¬rm that this modiï¬ed test-bench detects that each of the MemBlock instances is faulty.</strong> This was given as an assignment in <em>Verification and Testing of VLSI</em> course offered by <strong>Prof M. P. Desai</strong> at IIT Bombay. Attached is the detailed solution to this problem. We attach the VHDL code which is my solution. However, in my solution, I make an assumption that only adjacent cells can cause coupling/pattern sensitive/decoder faults. In practice, situation is much worse than that. We have used <strong>ghdl</strong> compiler to test it. <a href=http://dilawarnotes.files.wordpress.com/2010/11/solution.pdf target=_blank>solution_memory_testing</a> [sourcecode language=&ldquo;text&rdquo;] use std.textio.all; entity MemTest is end entity MemTest; architecture Behave of MemTest is &ndash; utility function: to increment an address function Increment(x: bit_vector) return bit_vector is alias lx: bit_vector(1 to x&rsquo;length) is x; variable ret_var: bit_vector(1 to x&rsquo;length); variable carry: bit; begin carry := &lsquo;1&rsquo;; for I in x&rsquo;length downto 1 loop ret_var(I) := lx(I) xor carry; carry := carry and lx(I); end loop; return(ret_var); end Increment; signal addr, addr2, data_in, data_out_df, data_out_saf, data_out_psf,data_out_cf : bit_vector(7 downto 0); signal read_en, write_en: bit; component MemBlock generic(has_decoder_fault, has_stuck_at_fault, has_psf, has_cf: boolean := false); port(addr, data_in: in bit_vector(7 downto 0); read_en, write_en: in bit; data_out: out bit_vector(7 downto 0)); end component; constant zero8: bit_vector(7 downto 0) := (others => &lsquo;0&rsquo;); &ndash; utility procedures &ndash; Write addr/data pair into memory using write_en procedure Write(signal addr: out bit_vector(7 downto 0); signal data: out bit_vector(7 downto 0); signal write_en: out bit; addr_var: in bit_vector(7 downto 0); data_var: in bit_vector(7 downto 0)) is begin addr &lt;= addr_var; data &lt;= data_var; wait for 1 ns; write_en &lt;= &lsquo;1&rsquo;; wait for 1 ns; write_en &lt;= &lsquo;0&rsquo;; wait for 1 ns; end procedure; &ndash; Read data from memory using read_en, addr. &ndash; NOTE: data must be present on data_out signal on &ndash; completion of procedure. procedure Read(signal addr: out bit_vector(7 downto 0); signal read_en: out bit; addr_var: bit_vector(7 downto 0)) is begin addr &lt;= addr_var; wait for 1 ns; read_en &lt;= &lsquo;1&rsquo;; wait for 1 ns; read_en &lt;= &lsquo;0&rsquo;; end procedure; begin &ndash; four memory blocks, each of which has one type of fault in it. &ndash; this has a decoder-fault mb_df: MemBlock generic map(has_decoder_fault => true, has_stuck_at_fault => false, has_psf => false, has_cf => false) port map(addr => addr, data_in => data_in, data_out => data_out_df, read_en => read_en, write_en => write_en); &ndash; this has stuck-at-faults in the array mb_saf: MemBlock generic map(has_decoder_fault => false, has_stuck_at_fault => true, has_psf => false, has_cf => false) port map(addr => addr, data_in => data_in, data_out => data_out_saf, read_en => read_en, write_en => write_en); &ndash; this has a pattern-sensitive-fault in the array. The neighbourhood for the &ndash; fault is adjacent bits in the same column of the array. mb_psf: MemBlock generic map(has_decoder_fault => false, has_stuck_at_fault => false, has_psf => true, has_cf => false) port map(addr => addr, data_in => data_in, data_out => data_out_psf, read_en => read_en, write_en => write_en); &ndash; this has some coupling faults in the array mb_cf: MemBlock generic map(has_decoder_fault => false, has_stuck_at_fault => false, has_psf => false, has_cf => true) port map(addr => addr, data_in => data_in, data_out => data_out_cf, read_en => read_en, write_en => write_en); &mdash;&mdash;&mdash;&mdash;- test process &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; process variable curr_addr, next_addr, temp_n_addr, temp_nn_addr, temp_data, next_data: bit_vector(7 downto 0); variable err_flag : boolean := false; variable err_add, l_psf, l_df, l_saf, l_cf : line; begin &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; &ndash; TEST SEQUENCE STARTS HERE &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; read_en &lt;= &lsquo;0&rsquo;; write_en &lt;= &lsquo;0&rsquo;; wait for 1 ns; curr_addr := (others => &lsquo;0&rsquo;); while true loop &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; &ndash; This test will test the stuck at 1/0 faults. &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; temp_data := (others => &lsquo;0&rsquo;); next_data := (others => &lsquo;1&rsquo;); &ndash; test for s-a-1 faults. Write(addr, data_in, write_en, curr_addr, temp_data); Read(addr, read_en, curr_addr); &ndash; assert yourself. assert (data_out_saf = temp_data) report &ldquo;Data mismatch in memory with stuck-at-1-fault&rdquo; severity ERROR; &ndash; log this error. if data_out_saf /= temp_data then write(l_saf, String'(&ldquo;A: &ldquo;)); write(l_saf, curr_addr); write(l_saf, String'(&rdquo; D: &ldquo;)); write(l_saf, temp_data); write(l_saf, String'(&rdquo; saf1: &ldquo;)); write(l_saf, data_out_saf); writeline(output, l_saf); end if; Write(addr, data_in, write_en, curr_addr, next_data); Read(addr, read_en, curr_addr); &ndash; assert yourself. assert (data_out_saf = next_data) report &ldquo;Data mismatch in memory with stuck-at-0-fault&rdquo; severity ERROR; &ndash; log this error. if data_out_saf /= next_data then write(l_saf, String'(&ldquo;A: &ldquo;)); write(l_saf, curr_addr); write(l_saf, String'(&rdquo; D: &ldquo;)); write(l_saf, next_data); write(l_saf, String'(&rdquo; saf0: &ldquo;)); write(l_saf, data_out_saf); writeline(output, l_saf); &ndash; NOTE : Must reset this cell while doing cf testing. Else &ndash; problem might occur in first and last cells. end if; &ndash; while true loop temp_data := (others => &lsquo;0&rsquo;); next_data := (others => &lsquo;1&rsquo;); temp_n_addr := Increment(curr_addr); &ndash; reset the cell we are going to test. Write(addr, data_in, write_en, temp_n_addr, temp_data); &ndash; give an up-transition at left location and read data. If there isa &ndash; coupling faults. This should change the value of cell from 0 to 1 Write(addr, data_in, write_en, curr_addr, temp_data); Write(addr, data_in, write_en, curr_addr, next_data); Read(addr, read_en, temp_n_addr); &ndash; read the next address. &ndash; Assert yourserf if you got it right. assert (data_out_cf = temp_data) report &ldquo;Data mismatch in memory with coupling l_at_0_u faults&rdquo; severity ERROR; &ndash; log this error. if data_out_cf /= temp_data then write(l_cf, String'(&ldquo;A: &ldquo;)); write(l_cf, temp_n_addr); write(l_cf, String'(&rdquo; 0lu &ldquo;)); write(l_cf, data_out_cf); writeline(output, l_cf); &ndash; reset the memory cell. Write(addr, data_in, write_en, temp_n_addr, temp_data); end if; &ndash; give a low transition at left location and read data. If there is a &ndash; coupling fault then this should change the value of cell from 0 to 1 Write(addr, data_in, write_en, curr_addr, temp_data); Read(addr, read_en, temp_n_addr); &ndash; read the next address. &ndash; Assert yourserf if you got it right. assert (data_out_cf = temp_data) report &ldquo;Data mismatch in memory with coupling l_at_0_d faults&rdquo; severity ERROR; &ndash; log this error. if data_out_cf /= temp_data then write(l_cf, String'(&ldquo;A: &ldquo;)); write(l_cf, temp_n_addr); write(l_cf, String'(&rdquo; 0ld &ldquo;)); write(l_cf, data_out_cf); writeline(output, l_cf); &ndash; reset the memory cell. Write(addr, data_in, write_en, temp_n_addr, temp_data); end if; &ndash; REPEAT IT FROM RIGHT SIDE temp_nn_addr := Increment(temp_n_addr); &ndash; give an up-transition at right location and read data. If there isa &ndash; coupling faults. This should change the value of cell from 0 to 1 Write(addr, data_in, write_en, temp_nn_addr, next_data); Read(addr, read_en, temp_n_addr); &ndash; read the next address. assert (data_out_cf = temp_data) report &ldquo;Data mismatch in memory with coupling r_at_0_u faults&rdquo; severity ERROR; &ndash; log this error. if data_out_cf /= temp_data then write(l_cf, String'(&ldquo;A: &ldquo;)); write(l_cf, temp_n_addr); write(l_cf, String'(&rdquo; 0ru &ldquo;)); write(l_cf, data_out_cf); writeline(output, l_cf); &ndash; reset the memory cell. Write(addr, data_in, write_en, temp_n_addr, temp_data); end if; &ndash; give a low transition at right location and read data. If there is a &ndash; coupling fault then this should change the value of cell from 0 to 1 Write(addr, data_in, write_en, temp_nn_addr, temp_data); Read(addr, read_en, temp_n_addr); &ndash; read the next address. &ndash; Assert yourserf if you are right. assert (data_out_cf = temp_data) report &ldquo;Data mismatch in memory with coupling r_at_0_d faults&rdquo; severity ERROR; &ndash; log this error. if data_out_cf /= temp_data then write(l_cf, String'(&ldquo;A: &ldquo;)); write(l_cf, temp_n_addr); write(l_cf, String'(&rdquo; 0rd &ldquo;)); write(l_cf, data_out_cf); writeline(output, l_cf); &ndash; reset the memory cell. Write(addr, data_in, write_en, temp_n_addr, temp_data); end if; temp_data := &ldquo;00000000&rdquo;; next_data := &ldquo;11111111&rdquo;; temp_n_addr := Increment(curr_addr); temp_nn_addr := Increment(temp_n_addr); &ndash; Following line will write 1 in next adress. Write(addr, data_in, write_en, temp_n_addr, next_data); &ndash; Give an up transition at left location and read for fault. Write(addr, data_in, write_en, curr_addr, next_data); Read(addr, read_en, temp_n_addr); &ndash; assert it. assert (data_out_cf = next_data) report &ldquo;Data mismatch in memory with coupling l_at_1_u faults&rdquo; severity ERROR; &ndash; log this error. if data_out_cf /= next_data then write(l_cf, String'(&ldquo;A: &ldquo;)); write(l_cf, temp_n_addr); write(l_cf, String'(&rdquo; 1lu &ldquo;)); write(l_cf, data_out_cf); &ndash; reset the memory cell. Write(addr, data_in, write_en, temp_n_addr, next_data); end if; &ndash; Give a down transition at left location. And read for faults. Write(addr, data_in, write_en, curr_addr, temp_data); Read(addr, read_en, temp_n_addr); &ndash; Assert yourserf if you are right. assert (data_out_cf = next_data) report &ldquo;Data mismatch in memory with coupling l_at_1_d faults&rdquo; severity ERROR; &ndash; log this error. if data_out_cf /= next_data then write(l_cf, String'(&ldquo;A: &ldquo;)); write(l_cf, temp_n_addr); write(l_cf, String'(&rdquo; 1lu &ldquo;)); write(l_cf, data_out_cf); &ndash; reset the memory cell. Write(addr, data_in, write_en, temp_n_addr, next_data); end if; &ndash; Give an up transition at right location. Write(addr, data_in, write_en, temp_nn_addr, next_data); Read(addr, read_en, temp_n_addr); &ndash; Assert yourserf if you are right. assert (data_out_cf = next_data) report &ldquo;Data mismatch in memory with coupling r_at_1_u faults&rdquo; severity ERROR; &ndash; log this error. if data_out_cf /= next_data then write(l_cf, String'(&ldquo;A: &ldquo;)); write(l_cf, temp_n_addr); write(l_cf, String'(&rdquo; 1ru &ldquo;)); write(l_cf, data_out_cf); writeline(output, l_cf); &ndash; reset the memory cell. Write(addr, data_in, write_en, temp_n_addr, next_data); end if; &ndash; Give a down transition at right location. Write(addr, data_in, write_en, temp_nn_addr, temp_data); Read(addr, read_en, temp_n_addr); &ndash; Assert yourserf if you are right. assert (data_out_cf = next_data) report &ldquo;Data mismatch in memory with coupling r_at_1_d faults&rdquo; severity ERROR; &ndash; log this error. if data_out_cf /= next_data then write(l_cf, String'(&ldquo;A: &ldquo;)); write(l_cf, temp_n_addr); write(l_cf, String'(&rdquo; 1rd &ldquo;)); write(l_cf, data_out_cf); &ndash; reset the memory cell. Write(addr, data_in, write_en, temp_n_addr, next_data); end if; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- &ndash; Test pattern for Pattern Sensitive Faults. &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- temp_data := (others => &lsquo;0&rsquo;); next_data := (others => &lsquo;1&rsquo;); temp_n_addr := Increment(curr_addr); temp_nn_addr := Increment(temp_n_addr); &ndash; reset the cell we are going to test. Write(addr, data_in, write_en, temp_n_addr, temp_data); &mdash;&mdash;- case 1 &ndash; Write 1 in left and 0 in right and check for PSF. Write(addr, data_in, write_en, curr_addr, next_data); Write(addr, data_in, write_en, temp_nn_addr, temp_data); &ndash; Now write 1 in the cell and read the same value. Write(addr, data_in, write_en, temp_n_addr, next_data); Read(addr, read_en, temp_n_addr); assert (data_out_psf = next_data) report &ldquo;Data can not be written due to l1r0 PSF.&rdquo; severity ERROR; &ndash; log this error. if data_out_psf /= next_data then write(l_psf, String'(&ldquo;A &ldquo;)); write(l_psf, temp_n_addr); write(l_psf, String'(&rdquo; l1r0 &ldquo;)); write(l_psf, data_out_psf); writeline(output, l_psf); end if; &ndash; write 0 in the cell and check for the PSF. Write(addr, data_in, write_en, temp_n_addr, temp_data); Read(addr, read_en, temp_n_addr); assert (data_out_psf = temp_data) report &ldquo;Data can not be written due to l1r0 PSF.&rdquo; severity ERROR; &ndash; log this error. if data_out_psf /= temp_data then write(l_psf, String'(&ldquo;A &ldquo;)); write(l_psf, temp_n_addr); write(l_psf, String'(&rdquo; l1r0 &ldquo;)); write(l_psf, data_out_psf); writeline(output, l_psf); end if; &mdash;&mdash;&ndash; case 2 &ndash; Write 1 in left and 1 in right and check for PSF Write(addr, data_in, write_en, curr_addr, next_data); Write(addr, data_in, write_en, temp_nn_addr, next_data); &ndash; Now write 1 in the cell and read the same value. Write(addr, data_in, write_en, temp_n_addr, next_data); Read(addr, read_en, temp_n_addr); assert (data_out_psf = next_data) report &ldquo;Data can not be written due to l1r1 PSF.&rdquo; severity ERROR; &ndash; log this error. if data_out_psf /= next_data then write(l_psf, String'(&ldquo;A &ldquo;)); write(l_psf, temp_n_addr); write(l_psf, String'(&rdquo; l1r1 &ldquo;)); write(l_psf, data_out_psf); writeline(output, l_psf); end if; &ndash; write 0 in the cell and check for the PSF. Write(addr, data_in, write_en, temp_n_addr, temp_data); Read(addr, read_en, temp_n_addr); assert (data_out_psf = temp_data) report &ldquo;Data can not be written due to l1r1 PSF.&rdquo; severity ERROR; &ndash; log this error. if data_out_psf /= temp_data then write(l_psf, String'(&ldquo;A &ldquo;)); write(l_psf, temp_n_addr); write(l_psf, String'(&rdquo; l1r1 &ldquo;)); write(l_psf, data_out_psf); writeline(output, l_psf); end if; &mdash;&mdash;&ndash; case 3 &ndash; Write 0 in left and 1 in right and check for PSF Write(addr, data_in, write_en, curr_addr, temp_data); Write(addr, data_in, write_en, temp_nn_addr, next_data); &ndash; Now write 1 in the cell and read the same value. Write(addr, data_in, write_en, temp_n_addr, next_data); Read(addr, read_en, temp_n_addr); assert (data_out_psf = next_data) report &ldquo;Data can not be written due to l0r1 PSF.&rdquo; severity ERROR; &ndash; log this error. if data_out_psf /= next_data then write(l_psf, String'(&ldquo;A &ldquo;)); write(l_psf, temp_n_addr); write(l_psf, String'(&rdquo; l1r1 &ldquo;)); write(l_psf, data_out_psf); writeline(output, l_psf); end if; &ndash; write 0 in the cell and check for the PSF. Write(addr, data_in, write_en, temp_n_addr, temp_data); Read(addr, read_en, temp_n_addr); assert (data_out_psf = temp_data) report &ldquo;Data can not be written due to l0r1 PSF.&rdquo; severity ERROR; &ndash; log this error. if data_out_psf /= temp_data then write(l_psf, String'(&ldquo;A &ldquo;)); write(l_psf, temp_n_addr); write(l_psf, String'(&rdquo; l0r1 &ldquo;)); write(l_psf, data_out_psf); writeline(output, l_psf); end if; &mdash;&mdash;&ndash; case 4 &ndash; Write 0 in left and 0 in right and check for PSF Write(addr, data_in, write_en, curr_addr, temp_data); Write(addr, data_in, write_en, temp_nn_addr, temp_data); &ndash; Now write 1 in the cell and read the same value. Write(addr, data_in, write_en, temp_n_addr, next_data); Read(addr, read_en, temp_n_addr); assert (data_out_psf = next_data) report &ldquo;Data can not be written due to l0r0 PSF.&rdquo; severity ERROR; &ndash; log this error. if data_out_psf /= next_data then write(l_psf, String'(&ldquo;A &ldquo;)); write(l_psf, temp_n_addr); write(l_psf, String'(&rdquo; l0r0 &ldquo;)); write(l_psf, data_out_psf); writeline(output, l_psf); end if; &ndash; write 0 in the cell and check for the PSF. Write(addr, data_in, write_en, temp_n_addr, temp_data); Read(addr, read_en, temp_n_addr); assert (data_out_psf = temp_data) report &ldquo;Data can not be written due to l0r0 PSF.&rdquo; severity ERROR; &ndash; log this error. if data_out_psf /= temp_data then write(l_psf, String'(&ldquo;A &ldquo;)); write(l_psf, temp_n_addr); write(l_psf, String'(&rdquo; l0r0 &ldquo;)); write(l_psf, data_out_psf); writeline(output, l_psf); end if; &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- &ndash; Decoder fault. &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; &ndash; NOTE : Ideally one should write 0 to a cell and write 1 to &ndash; all the cells which are 1 hamming distance away to cover all &ndash; the stuck-at-fautls in decoder. Here, we check immediate left &ndash; and right cell for fautls. Write(addr, data_in, write_en, temp_n_addr, next_data); &ndash; write all 1 in left and right cell. Write(addr, data_in, write_en, curr_addr, temp_data); Write(addr, data_in, write_en, temp_nn_addr, temp_data); Read(addr, read_en, temp_n_addr); assert (data_out_df = next_data) report &ldquo;Decoder fault - value written into some adjacent cell.&rdquo; severity ERROR; &ndash; log this error if data_out_df /= next_data then write(l_df, String'(&ldquo;To &ldquo;)); write(l_df, temp_n_addr); write(l_df, String'(&rdquo; From &ldquo;)); write(l_df, curr_addr); write(l_df, String'(&rdquo; DF &ldquo;)); write(l_df, data_out_df); writeline(output, l_df); &ndash; reset cells for next test. Write(addr, data_in, write_en, temp_n_addr, temp_data); Write(addr, data_in, write_en, temp_nn_addr, temp_data); &ndash; to make sure this does not interfere with other test. Write(addr, data_in, write_en, curr_addr, temp_data); end if; next_addr := temp_n_addr; &ndash; if all addresses have been reached, exit if(next_addr = &ldquo;11111111&rdquo;) then exit; end if; curr_addr := next_addr; end loop; assert false report &ldquo;Test completed.&rdquo; severity NOTE; wait; end process; end Behave; [/sourcecode]</p>
<h2 id=solution>Solution</h2>
<p>Use following commands to run the test. [sourcecode language=&ldquo;text&rdquo;] ghdl -i *.vhd ghdl -m memtest ghdl -r memtest &ndash;stop-time=40ms &ndash;vcd=dilawar.vcd [/sourcecode]</p>
</div>
<div class=tags>
<div class=taxosfloating_left>
<p>Categories</p>
</div>
<div class=termsfloating_right>
<p>
<a href=/categories/technology-and-engineering/>technology-and-engineering</a>
</p>
</div>
<div class=clearit></div>
<div class=tags>
<div class=taxosfloating_left>
<p>Tags</p>
</div>
<div class=termsfloating_right>
<p>
<a href=/tags/ghdl/>ghdl</a>
<a href=/tags/memory-testing/>memory-testing</a>
<a href=/tags/pattern-sensitive-faults/>pattern-sensitive-faults</a>
<a href=/tags/stuck-at-faults/>stuck-at-faults</a>
<a href=/tags/verification/>verification</a>
<a href=/tags/vhdl/>vhdl</a>
</p>
</div>
<div class=clearit></div>
</div>
</article>
</div>
</main>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-180197482-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<script src=/js/dark-mode.js></script>
</body>
</html>