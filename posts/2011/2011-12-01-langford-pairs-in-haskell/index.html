<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<title>Langford pairs in Haskell | Dilawar's Blog</title>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=generator content="Hugo 0.89.2">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=keywords content="langford-pairs">
<link rel=stylesheet type=text/css media=screen href=/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=/css/main.css>
<link rel=stylesheet type=text/css media=screen href=/css/all.css><link rel=stylesheet href=/css/katex.css crossorigin=anonymous>
<script defer src=/js/katex.js integrity=sha384-PFWG8XW41D5NzhNv5FegM1CUkw9nNLdWug8DuwnUoNEVop9n5frjcnbtsZtxTNjw crossorigin=anonymous></script>
<script defer src=/js/auto-render.js integrity=sha384-EN2q+JG5/3Z8gD7hT5WZqq+W+9wQR4P3IezfuZmGG5RkNXaaaks85seDJO7WkZlY crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script>
<meta property="og:title" content="Langford pairs in Haskell">
<meta property="og:description" content="\This implementation is not-very naive but it is not very efficient either. It can generate solutions up to n = 12, then it gets very slow.
This is an extremely horrible solution to generate langford pairs by dilawar@ee.iitb.ac.in succesfully finished on Nov 27, 2011 after two days of labour. Is is advised not to use this program in any real-time application. Its runs slower than Chacha Chaudary brain. One can achieve much better performace by using Arrays in Haskell.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://dilawar.github.io/posts/2011/2011-12-01-langford-pairs-in-haskell/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2011-12-01T00:00:00+00:00">
<meta property="article:modified_time" content="2011-12-01T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Langford pairs in Haskell">
<meta name=twitter:description content="\This implementation is not-very naive but it is not very efficient either. It can generate solutions up to n = 12, then it gets very slow.
This is an extremely horrible solution to generate langford pairs by dilawar@ee.iitb.ac.in succesfully finished on Nov 27, 2011 after two days of labour. Is is advised not to use this program in any real-time application. Its runs slower than Chacha Chaudary brain. One can achieve much better performace by using Arrays in Haskell.">
<meta itemprop=name content="Langford pairs in Haskell">
<meta itemprop=description content="\This implementation is not-very naive but it is not very efficient either. It can generate solutions up to n = 12, then it gets very slow.
This is an extremely horrible solution to generate langford pairs by dilawar@ee.iitb.ac.in succesfully finished on Nov 27, 2011 after two days of labour. Is is advised not to use this program in any real-time application. Its runs slower than Chacha Chaudary brain. One can achieve much better performace by using Arrays in Haskell."><meta itemprop=datePublished content="2011-12-01T00:00:00+00:00">
<meta itemprop=dateModified content="2011-12-01T00:00:00+00:00">
<meta itemprop=wordCount content="702">
<meta itemprop=keywords content="langford-pairs,">
</head>
<body>
<header>
<div id=titletext>
<h2 id=title><a href=https://dilawar.github.io>Dilawar's Blog</a></h2>
</div>
<div id=title-description>
<p id=subtitle>watch -n 1 /dev/null</p>
<div id=social>
<nav><ul>
<li><a href=https://github.com/dilawar><i title=Github class="icons fab fa-github"></i></a></li>
<li><a><i title="Switch Dark Mode" class="dark-mode icons fas fa-moon"></i></a></li>
</ul></nav>
</div>
</div>
<div id=mainmenu>
<nav>
<ul>
<li><a href=/>Home</a></li>
<li><a href=/posts>All posts</a></li>
<li><a href=/about>About</a></li>
<li><a href=/tags>Tags</a></li>
</ul>
</nav>
</div>
</header>
<main>
<div class=post>
<article>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>01</span>
<span class=rest>Dec 2011</span>
</div>
</div>
<div class=matter>
<h1 class=title>Langford pairs in Haskell</h1>
<p class=post-meta>
<span class=post-meta>
</span>
</p>
</div>
</div>
<div class=markdown>
<p>  \This implementation is not-very naive but it is not very efficient either. It can generate solutions up to n = 12, then it gets very slow.</p>
<p>This is an extremely horrible solution to generate langford pairs by
<a href=mailto:dilawar@ee.iitb.ac.in>dilawar@ee.iitb.ac.in</a> succesfully finished on Nov 27, 2011 after two days of
labour. Is is advised not to use this program in any real-time application. Its
runs slower than Chacha Chaudary brain.
One can achieve much better performace by using Arrays in Haskell.
This is discussed in Knuth, TAOP - Vol 4(a)</p>
<blockquote>
<p>mkZero n = take n [0,0..]
genBaseList n
     | n &lt; 1 = [] >     | otherwise = n : mkZero n ++ [n]
We are producing baselists e.g. for n=4, baselists are [1,0,1], [2,0,0,2],
[3,0,0,0,3] and [4,0,0,0,0,4].
allBaseLists n = map genBaseList [n,n-1..1]
Following horrible step is the core of our algorithm. In this step we use two
base-list. First list is known as topList while the other one is bottomList. To
fuse these lists, we first shift the top-list to right by prepending a 0 to it
and fuse it with bottom. Two lists are no fusable whenver both of them has
non-zero integer at the same place. This process stops when size of top list
become more than 2*n we stop. For example, for n = 3
Top   : 1 0 1    | 0 1 0 1 | 0 0 1 0 1 | 0 0 0 1 0 1 | size more than 2n
Bot   : 2 0 0 2  | 2 0 0 2 | 2 0 0 2   | 2 0 0 2
Fuse  : X        | 2 1 0 X | 2 0 1 2 1 | 2 0 0 X
Nothing    Nothing     Just       Nothing
^                        ^
|                        |
Two nozero             This is the only
Entries coincide       possible fusion.
In second step, we shift the bottom and fuse
Top   : 1 0 1    | 1 0 1      | 1 0 1         | 1 0 1
Bot   : 2 0 0 2  | 0 2 0 0 2  | 0 0 2 0 0 2   | size more than 2n
Fuse  : X        | 1 2 1 0 2  | 1 0 X
Nothing      Just        Nothing
fuseBothList [] y = Just y
fuseBothList x [] = Just x
fuseBothList (x:xs) (y:ys)
     | (x /= 0) && (y /= 0) = Nothing
     | otherwise = (helper $ fuseBothList xs ys)
                         where helper Nothing = Nothing
                               helper (Just p) = if y/=0 then Just (y:p)
                                                 else Just (x:p)</p>
<p>topRightShiftAndFuse t b n
     | length (t) > 2*n = []
     | fuseBothList t b == Nothing = topRightShiftAndFuse (0:t) b n
     | otherwise = (\(Just p) -> p:(topRightShiftAndFuse (0:t) b n)) (fuseBothList t b)</p>
<p>botRightShiftAndFuse t b n
     | length (b) > 2*n = []
     | fuseBothList t b == Nothing = botRightShiftAndFuse t (0:b) n
     | otherwise = (\(Just p) -> p:(botRightShiftAndFuse t (0:b) n)) (fuseBothList t b)</p>
</blockquote>
<p>At each step we get fused lists by above method. These lists are needed to be
fused with next list And now we should merge what we have fused. For example we
have got [0,2,0,0,2] and [1,2,1,0,2] from previous merge, now we need to merge
it with [3,0,0,0,3]. by doing so, we&rsquo;ll get the solution for n=3.</p>
<blockquote>
<p>mergeTopBottom t b n = (topRightShiftAndFuse t b n) ++ (botRightShiftAndFuse t b n)
Now rest is putting these function together to get the final solution.
initList n = allBaseLists n
mergeInto n = (\(x:xs) -> mergeTopBottom (head xs) x n) (initList n)
mergeFrom n = (\(x:y:zs) -> zs) (initList n)
This is my ultimate answer.
generateSol mergeFromList mergeIntoList n. It generates duplicate solution.
generateSol (b:[]) a n
     = foldr (++) [] $ map (\x -> mergeTopBottom b x n) a
generateSol (b:bs) (a) n
     = generateSol bs (foldr (++) [] (map (\x -> mergeTopBottom b x n) a)) n
And now I should combile all of them to write the top-most function.
langfordPair n = generateSol (mergeFrom n) (mergeInto n) n
totalPairs n = length (langfordPair n)
Who needs tests now!
test1 = mergeTopBottom [2,0,0,2] [3,0,0,0,3] 3
test2 = map (\x -> mergeTopBottom [1,0,1] x 3) test1
test4 = mergeThisList [2,0,0,2]
test5 = mergeThisList</p>
</blockquote>
</div>
<div class=tags>
<div class=taxosfloating_left>
<p>Categories</p>
</div>
<div class=termsfloating_right>
<p>
<a href=/categories/algorithms/>algorithms</a>
</p>
</div>
<div class=clearit></div>
<div class=tags>
<div class=taxosfloating_left>
<p>Tags</p>
</div>
<div class=termsfloating_right>
<p>
<a href=/tags/langford-pairs/>langford-pairs</a>
</p>
</div>
<div class=clearit></div>
</div>
</article>
</div>
</main>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-180197482-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<script src=/js/dark-mode.js></script>
</body>
</html>